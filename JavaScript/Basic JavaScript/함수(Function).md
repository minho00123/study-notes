# 함수(Function)
---
## 📌 Summary
> 일련의 과정을 문(statement)으로 구현하고, 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
## 📌 Description
- 함수는 입력을 받아 값을 출력한다.
	- 입력 = 인수(argument)
	- 함수 내부로 입력을 전달받는 변수 = 매개변수(parameter)
	- 출력 =  반환값(return value)
- 함수는 재사용이 가능해 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다.
- 함수는 객체지만, 일반 객체와는 다르게 함수는 호출할 수 있고 함수 객체만의 고유한 프로퍼티를 갖는다.
- 함수는 일급 객체다. 따라서 함수를 값처럼 자유롭게 사용할 수 있다.
- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.
### ◉ 함수 리터럴
```js
const f = function add(x, y) {
	return x + y;
}
```
- 함수는 객체 타입의 값이기 때문에 함수 리터럴로 생성할 수 있다.
- 함수 리터럴은 `function` 키워드, 함수 이름, 매개변수 목록, 함수 몸체로 구성된다.
#### ▪︎ 함수 리터럴 구성 요소
| 구성요소      | 설명                                                                                                                                                                                                                                  |
| ------------- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 함수 이름     | • 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다. <br/> • 함수 이름은 식별자 네이밍 규칙을 준수해야 한다. <br/> • 함수 이름은 생략할 수 있다.                                                                                 |
| 매개변수 목록 | • 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. <br/> • 함수를 호출할 때 지정한 인수가 순서대로 매개변수에 할당된다. <br/> • 매개변수는 함수 몸체 내에서 변수와 동일하게 취급되기 때문에 식별자 네이밍 규칙을 준수해야 한다. |
| 함수 몸체     | • 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다. <br/> • 함수 몸체는 함수 호출에 의해 실행된다.                                                                                               |

### ◉ 함수 정의(Function Definition)
```js
function add(x, y) {
	return x + y;
}
```
- 함수는 *함수 정의*를 통해 생성한다.
	- 함수 호출 전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정한다.
	- 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.
#### ▪︎ 함수 정의 방법
| 정의 방법            | 예시                                                  |
| -------------------- |:----------------------------------------------------- |
| 함수 선언문          | `function add(x, y) { return x + y; }`                |
| 함수 표현식          | `const add = function (x, y) { return x + y; }`       |
| Function 생성자 함수 | `const add = new Function('x', 'y', 'return x + y');` |
| 화살표 함수(ES6)     | `const add = (x, y) => x + y;`                        |

##### 1. 함수 선언문(Function Declaration)
```js
function add(x, y) {
	return x + y;
}
```
- 함수 선언문은 함수 리터럴과 형태가 동일하다.
	- 하지만 함수 선언문은 함수 이름을 생략할 수 없다.
- 함수 선언문은 표현식이 아닌 문이기 때문에 변수에 할당할 수 없다.
- 함수 선언문으로 생성한 함수는 자바스크립트 엔진에 의해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당한다.
	- 따라서 함수 선언문으로 생성한 함수를 호출한 것은 함수 이름이 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자이다.
##### 2. 함수 표현식(Function Expression)
```js
const add = function (x, y) {
	return x + y;
};
```
- 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 정의 방식이다.
- 일반적으로 함수 리터럴의 함수 이름을 생략한다.
	- 함수 이름을 생략한 경우를 "익명 함수"라고 한다. ↔ "기명 함수"
- 함수 선언문은 "표현식이 아닌 문"이고 함수 표현식은 "표현식인 문"이다.

> 💡 **함수 선언문 vs. 함수 표현식**
> • 함수 선언문과 함수 표현식으로 정의한 함수는 생성 시점이 다르다.
> 	- 함수 선언문은 런타임 이전에 함수 객체를 먼저 생성한다. 따라서 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료되어 있다. 이로 인해 함수 선언문 이전에 함수를 참조/호출할 수 있다.
> 		- 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 것을 함수 호이스팅(function hoisting)이라 한다.
> 	- 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다. 따라서 변수 선언은 런타임 이전에 실행되어 `undefined`로 초기화되지만 변수 할당문의 값은 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
> 		- 따라서 함수 표현식은 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.
> 		- 함수 표현식 이전에 함수를 참조하면 `undefined`로 평가된다. 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.
```js
// 함수 참조
console.dir(add); // ƒ add(x, y)
console.dir(sub); // undefined

// 함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError: sub is not a function

// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 표현식
const sub = function (x, y) {
	return x - y;
}
```

##### 3. Function 생성자 함수
```js
const add = new Function('x', 'y', 'return x + y');
```
- 자바스크립트가 기본으로 제공하는 빌트인 함수인 `Function` 생성자 함수를 이용하여 정의한 함수
- 매개변수 목록과 함수 몸체를 문자열로 전달하고, `new` 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다.
	- `new` 연산자 없이 호출해도 결과는 동일하다.
- `Function` 생성자 함수로 생성한 함수는 클로저(closure)를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작하기 때문에 일반적으로 사용하지 않는다.
```js
const add1 = (function () {
	const a = 10;
	return function (x, y) {
		return x + y + a;
	}
}());

console.log(add1(1, 2)); // 13

const add2 = (function () {
	const a = 10;
	return new Function('x', 'y', 'return x + y + a;');
}());

console.log(add2(1, 2)); // ReferenceError: a is not defined
```
##### 4. 화살표 함수(Arrow Function)
```js
const add = (x, y) => x + y;
```
- `function` 키워드 대신 화살표(`=>`)를 사용해 좀 더 간략한 방법으로 함수를 선언한 함수.
- 항상 익명함수로 정의한다.
- 화살표 함수는 내부 동작 또한 간략화되어 있다.
	- 생성자 함수로 사용할 수 없다.
	- 기존 함수와 `this` 바인딩 방식이 다르다.
	- `prototype` 프로퍼티가 없다.
	- `arguments` 객체를 생성하지 않는다.
### ◉ 함수 호출(Function Call/Invoke)
```js
const result = add(2, 5);
```
- 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는 것
- 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고, 반환값을 반환한다.
- 함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.
- 함수 호출 연산자 내에는 0개 이상의 인수를 쉼표로 구분해서 나열한다.
- 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다. 이때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행되기 시작한다.
### ◉ 함수 종류
#### ▪︎ 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)
- 함수 정의와 동시에 즉시 호출되는 함수
- 단 한 번만 호출되며 다시 호출할 수 없다.
	- 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있다.
- 반드시 그룹 연산자 ( ... )로 감싸야 한다.
	- 그룹 연산자로 함수를 감싸는 이유는 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서다.
	- 따라서 리터럴을 평가해 함수 객체를 생성할 수 있다면 그룹 연산자 이외의 연산자를 사용해서 즉시 실행 함수를 정의할 수 있다.
	- 일반적으로는 첫 번째 방식을 사용한다.

```js
(function () {
	// ...
}());

(function () {
	 // ...
})());

!function () {
	// ...
}();

+function () {
	// ...
}();

function () { // SyntaxError: Function statements require a function name
	// ...
}();
```
- 익명 함수를 사용하는 것이 일반적이다.
```js
// 익명 즉시 실행 함수
(function () {
	const a = 3;
	const b = 5;
	return a * b;
}());
```
- 기명 함수도 사용할 수 있지만 그룹 연산자 ( ... ) 내의 기명 함수는 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자이기 때문에 다시 호출할 수는 없다.
```js
(function foo() {
	const a = 3;
	const b = 5;
	return a * b;
}());

foo(); // ReferenceError: foo is not defined
```
- 그룹 연산자의 피연산자는 값으로 평가되기 때문에 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.
```js
console.log(typeof (function f(){})); //function
console.log(typeof (function (){})); // function
```
- 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.
```js
const res = (function () {
	const a = 3;
	const b = 5;
	return a * b;
}());

console.log(res); // 15

rest = (function (a, b) {
	return a * b;
}(3, 5));

console.log(res); // 15
```
#### ▪︎ 재귀 함수(Recursive Function)
```js
function countdown(n) {
	if (n < 0) return;
	console.log(n);
	countdown(n - 1);
}
```
- 자기 자신을 호출하는 함수
	- 반복되는 처리를 위해 주로 사용한다.
- 함수 표현식으로 정의한 함수 내부에서는 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 재귀 호출할 수 있다. 단, 함수 외부에서 함수를 호출할 때는 반드시 함수가 가리키는 식별자로 해야 한다.
- 재귀 함수는 자신을 무한 재귀 호출하기 때문에 재귀 함수 내에는 탈출 조건을 반드시 만들어야 한다.
	- 탈출 조건이 없으면 함수가 무한히 호출되어 스택 오버플로(stack overflow) 에러가 발생한다.
- 재귀 함수는 반복되는 처리를 반복문 없이 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 위험이 있고, 이로 인해 스택 오버플로 에러를 발생시킬 수 있으므로 주의해서 사용해야 한다.
	- 따라서 재귀 함수는 반복문을 사용하는 것보다 재귀함수를 사용하는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직하다.
#### ▪︎ 중첩 함수(Nested Function)
```js
function outer() {
	const x = 1;

	function inner() {
		const y = 2;
		console.log(x + y); // 3
	}

	inner();
}

outer();
```
- 함수 내부에 정의된 함수
- 내부 함수(inner function)라고도 한다.
	- 중첩 함수를 포함하는 함수는 외부 함수(outer function)라 부른다.
- 중첩 함수는 외부 함수 내부에서만 호출할 수 있다.
- 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수(helper function)의 역할을 한다.
#### ▪︎ 콜백 함수(Callback Function)
- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
	- 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라고 한다.
- 콜백 함수는 고차 함수에 전달되어 헬퍼 함수의 역할을 한다.
- 중첩 함수는 고정되어 있어 교체하기 어렵지만, 콜백 함수는 함수 외부에서 고차 함수 내부로 주입하기 때문에 교체가 자유롭다는 장점이 있다.
- 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.
- 콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.
	- 따라서 고차 함수에 콜백 함수를 전달할 때 콜백 함수를 호출하지 않고 함수 자체를 전달해야 한다.
- 콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.
```js
repeat(5, function (i) {
	if (i % 2) console.log(i);
}); // 1 3
```
- 콜백 함수는 함수형 프로그래밍 패러다임뿐만 아니라 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등)에 활용되는 중요한 패턴이다.
```js
document.getElementById('myButton').addEventListener('click', function () {
	console.log('button clicked!');
});

setTimeout(function () {
	console.log('1초 경과');
}, 1000);
```
- 콜백 함수는 배열 고차 함수에서도 사용된다. 
```js
const res = [1, 2, 3].map(function (item) {
	return item * 2;
});
console.log(res); // [2, 4, 6]
```
#### ▪︎ 순수 함수(Pure Function)와 비순수 함수(Impure Function)
##### - 순수 함수
```js
let count = 0; // 현재 카운트를 나타내는 상태

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
function increase(n) {
	return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```
- 함수형 프로그래밍에서 어떤 외부 상태에 의존 및 변경하지 않는 함수를 순수 함수라 한다.
- 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
	- 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 값을 생성해 반환한다.
- 함수 내부 상태가 호출될 때마다 값이 변화(Ex. 현재 시간)한다면 순수 함수가 아니다.
- 순수 함수는 일반적으로 최소 하나 이상의 인수를 전달 받는다.
	- 인수를 전달 받지 않으면 언제나 동일한 값을 반환하기 때문에 의미가 없다.
- 순수 함수는 인수를 변경하지 않는 것이 기본이다. 즉, 인수의 불변성을 유지한다.
- 순수 함수는 함수의 외부 상태를 변경하지 않는다.
##### - 비순수 함수
```js
let count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.

// 비순수 함수
function increase() {
	return ++n; // 외부 상태에 의존하며 외부 상태를 변경한다.
}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.
increase();
console.log(count); // 1

increase();
console.log(count); // 2
```
- 외부 상태에 의존하거나 외부 상태를 변경하는 함수를 비순수 함수라고 한다.
	- 함수 외부 상태에 따라 반환값이 달라진다.
	- 외부 상태에는 전역 변수, 서버 데이터, 파일, Console, DOM 등이 있다.
- 비순수 함수는 외부 상태를 변경하는 부수 효과(side effect)가 있다 .
- 위 예제와 같이 인수를 전달받지 않고 함수 내부에서 외부 상태를 직접 참조하면 외부 상태에 의존하게 되어 반환값이 변할 수 있고, 외부 상태도 변경할 수 있으므로 비순수 함수가 된다.
- 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 객체를 전달받으면 비순수 함수가 된다.

- 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 따라서 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다.
## 📌 Reference
- "모던 자바스크립트 Deep Dive" by 이웅모, p.154-188
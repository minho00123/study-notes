# 변수(Variable)
---
## 📌 Summary
> 변경 가능한 데이터를 담는 공간
## 📌 Description
- 값(Value)이 저장된 메모리 공간을 가리킨다.
- **변수 이름(변수명)**: 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
	- 변수 이름도 식별자 네이밍 규칙을 따른다.
- **변수 값**: 변수에 저장된 값
- 변수 이름과 값은 실행 컨텍스트 내에 key / value 형식인 객체로 등록되어 관리된다.
### ◉ 변수 선언(Declaration)
- 변수를 생성하는 것을 말한다.
- 값을 저장하기 위해 메모리 공간을 확보(allocate)하고, 변수명과 확보된 메모리 주소를 연결해서 값을 저장할 수 있게 준비한다.
- var, let, const 키워드를 사용하여 변수를 선언한다.
- 변수 선언 2단계:
	1. 선언 단계: 변수명을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
	2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고, 암묵적으로 `undefined`를 할당해 초기화 한다.
		※ 초기화(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다.
		- 초기화 단계를 거치는 이유는 메모리 공간에 Garbage Value를 제거하기 위함이다.
### ◉ 변수 할당(Assignment; 대입, 저장)
- 변수에 값을 저장하는 것을 말한다.
- 지정 연산자 `=`를 사용하여 변수를 할당한다.
	- 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.
- 변수 선언은 런타임 이전에 먼저 실행되지만 할당은 런타임에 실행된다.
- 변수 선언과 할당을 하나의 문장으로 표현해도 자바스크립트 엔진은 2개의 문으로 나누어 각각 실행한다.
### ◉ 변수 참조(Reference)
- 변수에 저장된 값을 읽어 들이는 것을 말한다.
### ◉ 변수 재할당(Reallocation)
- 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것을 말한다.
- 새로운 메모리 공간을 확보하여 할당된 값을 저장한다.
- 재할당은 변수에 저장된 값을 다른 값으로 변경한다. 그래서 변수라고 한다.
## 📌 Examples
``` js
var foo;          // 변수 선언
foo = 1;          // 변수 할당
console.log(foo); // 변수 참조
foo = 2;          // 변수 재할당
```
## 📌 Supplement (전역 변수의 문제점)
- 전역 변수를 사용하면 다음과 같은 문제점을 가진다:
#### 1. 암묵적 결합
- 전역변수는 모든 코드가 참조/할당/변경할 수 있는 변수를 사용하겠다는 의도로 선언한 것이기 때문에 암묵적 결합(implicit coupling)을 허용한다.
- 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.
#### 2. 긴 생명 주기
- 전역 변수는 생명 주기가 길기 때문에 메모리 리소스도 오랜 기간 소비한다.
- 전역 변수의 상태를 변경할 수 있는 시간이 길어 기회도 많아진다.
- 지역 변수는 생명 주기가 훨씬 짧아 변수의 상태를 변경할 수 있는 시간도 짧고 기회도 적다.
	- 따라서 상태 변경에 의한 오류가 발생할 확률이 작다. 또한 메모리 리소스도 짧은 시간만 소비한다.
#### 3. 스코프 체인 상에서 종점에 존재
- 변수를 검색할 때 전역 변수가 가장 마지막에 검색되기 때문에 검색 속도가 가장 느리다.
#### 4. 네임스페이스 오염
- 자바스크립트에서는 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다.
	- 따라서 다른 파일 내에 동일한 이름을 가진 전역 변수나 전역 함수가 같은 스코프에 존재하면 의도치 않은 결과가 일어난다.
### ◉ 전역 변수 사용 억제 방법
- 변수의 스코프는 좁을수록 좋다. 따라서 되도록이면 지역 변수를 사용하는 것이 좋다.
#### 1. 즉시 실행 함수
- 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.
```js
(function () {
	var foo = 10;
	// ...
}());

console.log(foo); // ReferenceError: foo is not defined
```
- 이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.
#### 2. 네임스페이스 객체
- 전역에 네임스페이스(namespace) 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.
```js
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = 'Lee';

console.log(MYAPP.name); // Lee
```
- 네임스페이스 객체에 또 다른 네임스페이스 객체를 프로퍼티로 추가해서 네임스페이스를 계층적으로 구성할 수도 있다.
```js
var MYAPP = {};

MYAPP.person = {
	name: 'Lee',
	address: 'Seoul'
};

console.log(MYAPP.person.name); // Lee
```
- 네임스페이스를 분리해서 식별자 충돌을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하진 않다.
#### 3. 모듈 패턴
- 모듈 패턴은 클로저를 기반으로 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.
- 모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 것이다.
	- 캡슐화(encapsulation)는 객체의 프로퍼티와 메서드를 하나로 묶는 것을 말한다.
	- 캡슐화는 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 하는데 이를 정보 은닉(information hiding)이라 한다.
- 자바스크립트는 `public`, `private`, `protected` 등의 접근 제한자를 제공하지 않는다. 따라서 모듈 패턴은 전역 네임스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용한다.
```js
var Counter = (funtion() {
	// private 변수
	var num = 0;

	// 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
	return {
		increase() {
			return ++num;
		},
		decrease() {
			return --num;
		}
	};
}());

console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```
- 위 예제의 즉시 실행 함수는 객체를 반환한다.
	- 이 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다.
	- 이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버(public member)다.
	- 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버(private member)가 된다.
#### 4. ES6 모듈
- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.
	- 따라서 모듈 내에서 `var` 키워드로 선언한 변수는 전역 변수가 아니며 `window` 객체의 프로퍼티도 아니다.
- `script` 태그에 `type="module"` 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장는 `mjs`를 권장한다.
```html
<script type="module" src="lib.mjs"></script>
<script type="module" src= "app.mjs"></script>
```
## 📌 Reference
- "모던 자바스크립트 Deep Dive" by 이웅모, p.34-49, 200-207